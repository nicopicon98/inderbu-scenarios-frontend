import { ReservationRepository as DomainReservationRepository } from '../domain/ReservationDomain';\nimport { ReservationRepository as ApiReservationRepository } from '../api/reservationRepository';\nimport { PaginatedReservations, PaginationQuery } from '../model/types';\n\n// \u2705 DDD: Adapter pattern - bridges existing API repository to domain interface\nexport class ReservationRepositoryAdapter implements DomainReservationRepository {\n  constructor(private readonly apiRepository: ApiReservationRepository) {}\n\n  async findByUserId(\n    userId: number, \n    pagination: PaginationQuery\n  ): Promise<PaginatedReservations> {\n    // Adapt domain pagination to API query format\n    const query = {\n      page: pagination.page,\n      limit: pagination.limit\n    };\n    \n    // Use existing API repository method\n    return this.apiRepository.getByUserId(userId, query);\n  }\n\n  async findById(reservationId: number): Promise<any> {\n    return this.apiRepository.getById(reservationId);\n  }\n\n  async cancel(reservationId: number, reason?: string): Promise<void> {\n    // TODO: Implement proper cancellation when needed\n    // For now, update state to cancelled\n    await this.apiRepository.updateState(reservationId, { stateId: 3 }); // Assuming 3 = cancelled\n  }\n\n  async create(reservationData: any): Promise<any> {\n    return this.apiRepository.create(reservationData);\n  }\n}\n\n// \u2705 Factory function for dependency injection\nexport function createReservationRepositoryAdapter(\n  apiRepository: ApiReservationRepository\n): DomainReservationRepository {\n  return new ReservationRepositoryAdapter(apiRepository);\n}\n