import { UserRepository as DomainUserRepository, UserNotFoundError } from '../domain/UserRepository';\nimport { UserRepository as ApiUserRepository } from '../api/userRepository';\nimport { User } from '../model/types';\n\n// \u2705 DDD: Adapter pattern - bridges existing API repository to domain interface\nexport class UserRepositoryAdapter implements DomainUserRepository {\n  constructor(private readonly apiRepository: ApiUserRepository) {}\n\n  async findById(userId: number): Promise<User | null> {\n    try {\n      // For now, we can only get current user from the API\n      // This is a limitation of the current API design\n      const currentUser = await this.apiRepository.getCurrentUser();\n      \n      // If the requested user is the current user, return it\n      if (currentUser.id === userId) {\n        return currentUser;\n      }\n      \n      // Otherwise, we don't have access to arbitrary user data\n      // In a real implementation, we'd have a proper user service\n      return null;\n    } catch (error) {\n      // If we can't get current user (not authenticated), return null\n      return null;\n    }\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    // TODO: Implement when API supports it\n    throw new Error('findByEmail not implemented - API limitation');\n  }\n\n  async create(userData: any): Promise<User> {\n    // This maps to register, but register doesn't return user data\n    await this.apiRepository.register(userData);\n    // We'd need to login or get the created user somehow\n    throw new Error('create not fully implemented - API limitation');\n  }\n\n  async update(userId: number, userData: any): Promise<User> {\n    // TODO: Implement when API supports user updates\n    throw new Error('update not implemented - API limitation');\n  }\n}\n\n// \u2705 Factory function for dependency injection\nexport function createUserRepositoryAdapter(\n  apiRepository: ApiUserRepository\n): DomainUserRepository {\n  return new UserRepositoryAdapter(apiRepository);\n}\n